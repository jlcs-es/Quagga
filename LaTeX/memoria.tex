\documentclass{article}
\usepackage[spanish]{babel}
\usepackage[onehalfspacing]{setspace}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{fullpage}
\usepackage{color}
\usepackage{fancyvrb}
\usepackage{hyperref}
\hypersetup{%
	pdfborder = {0 0 0}
}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
	backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
	basicstyle=\footnotesize,        % the size of the fonts that are used for the code
	breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
	breaklines=true,                 % sets automatic line breaking
	captionpos=b,                    % sets the caption-position to bottom
	commentstyle=\color{mygreen},    % comment style
	frame=single,                    % adds a frame around the code
	keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
	numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
	numbersep=5pt,                   % how far the line-numbers are from the code
	numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
	rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
	showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
	showstringspaces=false,          % underline spaces within strings only
	showtabs=false,                  % show tabs within strings adding particular underscores
	stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
	stringstyle=\color{mymauve},     % string literal style
	tabsize=4,
	title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}


\author{José Luis Cánovas Sánchez}
\title{ARQUITECTURAS DE REDES AVANZADAS\\QUAGGA}

\begin{document}
\maketitle

\begin{center}
	\includegraphics[scale=0.3]{images/mascota.png}
\end{center}

\begin{abstract}
	En este informe se redacta el despliegue de un escenario de red IPv6 usando la herramienta Quagga.
\end{abstract}

\tableofcontents

\section{Introducción}

Quagga es un proyecto de software que provee de utilidades para encaminamiento de red en sistemas UNIX, proveyendo el demonio zebra originario de otro proyecto y que permite aplicar configuraciones de algoritmos de encaminamiento a las tablas de red de la máquina. Los algoritmos se ejecutan como demonios que toman la información de la red y aplican protocolos conocidos, tales como OSPF, RIP, IS-IS y BGP, en múltiples de sus versiones, y por medio de zebra los aplican a la red.

\begin{center}
	\begin{BVerbatim}
+----+  +----+  +-----+  +-----+
|bgpd|  |ripd|  |ospfd|  |zebra|
+----+  +----+  +-----+  +-----+
|
+---------------------------|--+
|                           v  |
|  UNIX Kernel  routing table  |
|                              |
+------------------------------+

    Quagga System Architecture
	\end{BVerbatim}
\end{center}

Vamos a configurar tres de estos protocolos con Quagga en cuatro máquinas que harán las veces de routers. %TODO: comprobar número de sección
En la sección 2 se muestra la topología que se va a implementar. En las secciones 3 a 6 se explicará cómo instalar y configurar Quagga con los mecanismos OSPF, RIP y BGP para IPv6.

La topología usada en este estudio de Quagga se asemeja mucho a la de la práctica 1 de ARA, pero se puede llevar a otros proyectos, como LEGO, fácilmente. Más adelante se muestra la topología en \autoref{fig:topology}, y con hacer corresponder R1 y R2 con los routers de las organizaciones de LEGO, las redes XXXX:0:1::/64 con las subredes de cada organización, y las subredes XXXX::/64 con una subred un nivel más interna, tenemos la topología de LEGO ampliada. La salida a internet se debería realizar con tunelado a IPv4 en R1 y R2, si no se dispone de IPv6 pública. En caso de tener un rango de direcciones IPv6 públicas, habría que cambiar los valores de cada subred para que sean válidos, pero queda fuera de este estudio.

\section{Topología de trabajo}


Partimos de dos Sistemas Autónomos con números 17 y 71 (curiosidad, son primos \hyperref{https://en.wikipedia.org/wiki/Permutable_prime}{}{}{\underline{permutables}}  entre sí) y mecanismo de encaminamiento interno por OSPF, con un área backbone y un área 1 stub para el AS17, un mecanismo basado en RIPng para el AS1 y BGP entre ambos AS, como se muestra en la \autoref{fig:topology}.


\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.29]{images/Topology.png}
	\caption{Topología}
	\label{fig:topology}
\end{figure}

\hfill

Esta topología lógica la llevamos a la práctica con Virtual Box, con cuatro máquinas Debian sin interfaz gŕafica, y con tarjetas de red virtuales configuradas como redes internas del siguiente modo:

\begin{itemize}

	\item R1: Adaptador 1 Red Interna \textit{AS17} - Adaptador 2 Red Interna \textit{interAS} - Adaptador 3 NAT.

	\item R2: Adaptador 1 Red Interna \textit{AS71} - Adaptador 2 Red Interna \textit{interAS} - Adaptador 3 NAT.

	\item R3: Adaptador 1 Red Interna \textit{AS17} - Adaptador 2 Red Interna \textit{AS17Area1} - Adaptador 3 NAT.

	\item R4: Adaptador 1 Red Interna \textit{AS71} - Adaptador 2 Red Interna \textit{AS71Subred} - Adaptador 3 NAT.

\end{itemize}

Con el NAT conseguimos salida a internet para poder descargar los ficheros de configuración. Con las otras conseguimos simular los switchs y conectar cada router por las interfaces correspondientes.

La configuración de \textit{/etc/network/interfaces} sería, por ejemplo para R1:

\begin{BVerbatim}
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet6 static
address 3FE0:0:1::1
netmask 64

auto eth1
iface eth1 inet6 static
address 3FE0::1
netmask 64

auto eth2
iface eth2 inet dhcp
\end{BVerbatim}


Desde Quagga también se podrían configurar usando las órdenes:

\begin{verbatim}
	interface eth0
	no shutdown
	ipv6 address 3FE0:0:1::1/64
\end{verbatim}

Y sustituyendo eth0 y la dirección ipv6 por cada inerfaz correspondiente y su dirección.

Como trabajamos con máquinas virtuales podemos trabajar con \textit{/etc/network/interfaces} para una topología inicial, y en caso de que ya no nos valga, modificar la configuración mediante Quagga para ir adaptándola, en vez de editar \textit{/etc/network/interfaces}.


\section{Instalar Quagga}

%TODO: http://www.nongnu.org/quagga/docs/docs-info.html#IPv6-Support

Para facilitar las pruebas, hay preparado un fichero Makefile que recibe como parámetro el router a configurar (r1, r2, r3 o r4), y ejecuta un script \textit{install.sh} que instala por aptitude el paquete \textit{quagga}.
 Con esto no es suficiente para que quagga funcione, ni tampoco para poder iniciar su consola de configuración. Para ello se crean en \textit{/etc/quagga/}
 los ficheros \textit{zebra.conf}, \textit{bgpd.conf}, \textit{ospf6d.conf}, \textit{ripngd.conf} y \textit{vtysh.conf} con usuario quagga y grupo quaggavty.

 A todos los ficheros menos a \textit{vtysh.conf} se les añade la línea \textit{password pwd} donde pwd será la contraseña para poder configurar el demonio por su propia terminal. El fichero \textit{vtysh.conf} configura la terminal vtysh, que permite controlar todos los demonios, al estilo de la terminal de un router Cisco, y para mayor comodidad, se escribe \textit{username root nopassword} para no necesitar iniciar sesión cada vez.

 Con esto los demonios podrían iniciarse sin problemas, pero falta decirle a Quagga qué demonios iniciar. Para ello el fichero \textit{/etc/quagga/daemons} se reescribe con:

 \begin{verbatim}
	 zebra=yes
	 bgpd=yes
	 ospfd=no
	 ospf6d=yes
	 ripd=no
	 ripngd=no
	 isisd=no
	 babeld=no
 \end{verbatim}

 Cambiando por yes o no según queramos activar o no cada demonio. El de zebra es obligatorio si queremos que se apliquen las tablas de rutas de los demonios al sistema real, pero si sólo se quiere ejecutar el protocolo sin afectar a la máquina, para pruebas por ejemplo, se puede desactivar.


 Finalmente habría que reiniciar Quagga con \textit{/etc/init.d/quagga restart}, lo cual hace el Makefile automáticamente y facilita al añadir una regla exta de r1-r4 llamada restart.

 

\section{Configuración de OSPF}

La configuración por comandos de OSPFv3 partiendo del punto de entrada de \textit{sudo vtysh} sería:

\begin{lstlisting}
configure terminal
router ospf6
router-id a.b.c.d
interface ethx area e.f.g.h
redistribute connected
redistribute prot
exit
exit
write
\end{lstlisting}

Donde a.b.c.d se sustituye por un ID para el router en forma de dirección ipv4. Para R1 elegimos 1.1.1.1 y para R3 2.2.2.2.

Las áreas se identifican también con direcciones tipo ipv4 sustituyendo el valor en e.f.g.h, y nótese que no es necesario ir a la configuración de la interfaz y activar ahí ospf, quagga lo hace automáticamente desde la configuración de ospf al indicar la interfaz, aquí sustituyendo ethx por la interfaz correspondiente. Para las áreas la 0.0.0.0 será la backbone, y la 0.0.0.1 la segunda área de R3.

Para anunciar las redes que no están incluidas en las áreas de OSPF, se debe indicar con redistribute, en el caso de R1 connected y bgp.
%TODO: quitar bgp si al final no.

Para R3 la línea de \textit{interface} habrá que ejecutarla una vez por cada interfaz y su área, y no haría falta el redistribute pues todas sus redes están en el AS gestionado con OSPF.

\hfill

Los ficheros de configuración generados al final por Quagga son casi idénticos a los de Cisco, y podrían ser la lista de comandos a ejecutar, excepto que añaden la información de las interfaces que deben usar ospf.

%TODO: poner ficheros ospf6d.conf


\section{Configuración de RIPng}

La configuración por comandos de RIPng partiendo del punto de entrada de \textit{sudo vtysh} sería:

\begin{lstlisting}
configure terminal
router ripng
network ethx
redistribute connected
redistribute prot
exit
exit
write
\end{lstlisting}

La configuración de RIPng es aún más sencilla que OSPF, donde además Quagga nos facilita el definir las redes a distribuir inticando directamente la interfaz donde antes pone network ethx.

Para que R2 anuncie las rutas a redes que quedan fuera del AS administrado por RIPng, al igual que en OSPF, se debe añadir la orden redistribute, anunciando las redes directamente conectadas y las aprendidas por bgp.
%TODO: quitar bgp si no se hace

En R4 no hacen falta las líneas \textit{redistribute} y habría que poner la orden network ethx por cada una de las dos interfaces que tiene y quedan dentro del AS.

Los ficheros de configuración del demonio ripngd generados son también parecidos a los de Cisco y en este caso son los comandos ejecutados antes:

%TODO: poner ficheros ripngd.conf

\section{Configuración de BGP}
% http://www.cisco.com/c/en/us/td/docs/ios/12_2/ip/configuration/guide/fipr_c/1cfbgp.html#wp1001080

%
%!
%router bgp 13
%bgp router-id 1.1.1.1
%no bgp default ipv4-unicast
%!--- Without configuring ""no bgp default ipv4-unicast"" only IPv4 will be !--- advertised
%bgp log-neighbor-changes
%neighbor 2001:ABCD::2 remote-as 50
%!
%address-family ipv6
%neighbor 2001:ABCD::2 activate
%network 3FE0:0:1::/64
%network 3FE0::/64
%exit-address-family
%!


\end{document}


% http://www.nongnu.org/quagga/docs/docs-info.html
